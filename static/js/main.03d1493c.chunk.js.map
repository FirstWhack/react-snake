{"version":3,"sources":["game/Game.ts","game/Snake.tsx","index.tsx"],"names":["DifficultyMultiplier","CONSTANTS","gridSize","tileSizeMultiplier","tileSize","this","initialGameState","playerPosition","x","y","applePosition","Math","floor","random","trail","tailSize","velocityByKeyCode","handleKeyDown","setVelocity","keyCode","Snake","canvasRef","React","setVelocitySetter","current","canvas","ctx","getContext","game","difficulty","fps","onUpdate","newGameState","velocity","newVelocity","frameInterval","then","Date","now","mutableGameState","animate","requestAnimationFrame","elapsed","fillStyle","fillRect","width","height","px","py","ax","ay","newPlayerPosition","newTailSize","i","length","isOnApple","JSON","stringify","concat","slice","startGame","MEDIUM","className","onKeyDown","bind","tabIndex","ref","rootElement","document","getElementById","render"],"mappings":"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","file":"static/js/main.03d1493c.chunk.js","sourcesContent":["export const CONSTANTS = {\r\n  gridSize: 20,\r\n  tileSizeMultiplier: 0.9,\r\n  get tileSize() {\r\n    return this.gridSize * this.tileSizeMultiplier;\r\n  }\r\n};\r\n\r\nexport interface Velocity {\r\n  x: number;\r\n  y: number;\r\n}\r\n\r\nexport interface GameState {\r\n  playerPosition: { x: number; y: number };\r\n  applePosition: {\r\n    x: number;\r\n    y: number;\r\n  };\r\n  trail: { x: number; y: number }[];\r\n  tailSize: number;\r\n}\r\n\r\nexport const initialGameState = {\r\n  playerPosition: { x: CONSTANTS.gridSize / 2, y: CONSTANTS.gridSize / 2 },\r\n  applePosition: {\r\n    x: Math.floor(Math.random() * CONSTANTS.tileSize),\r\n    y: Math.floor(Math.random() * CONSTANTS.tileSize)\r\n  },\r\n  trail: [{ x: 10, y: 10 }],\r\n  tailSize: 5\r\n};\r\n\r\nexport enum DifficultyMultiplier {\r\n  EASY = 0.95,\r\n  MEDIUM = 0.9,\r\n  HARD = 0.8\r\n}\r\n\r\nconst START_FPS = 6;\r\n\r\nexport const startGame = (\r\n  difficulty: DifficultyMultiplier,\r\n  fps: number,\r\n  canvas: HTMLCanvasElement,\r\n  ctx: CanvasRenderingContext2D,\r\n  onUpdate = (newGameState: GameState) => {}\r\n) => {\r\n  let velocity = {\r\n    x: 0,\r\n    y: 0\r\n  };\r\n  const setVelocity = (newVelocity: Velocity) => {\r\n    velocity = newVelocity;\r\n  };\r\n  // start with 5 fps\r\n  let frameInterval = 1000 / START_FPS;\r\n  let then = Date.now();\r\n  // to be used by the render loop\r\n  let mutableGameState = { ...initialGameState };\r\n\r\n  const animate = (\r\n    canvas: HTMLCanvasElement,\r\n    ctx: CanvasRenderingContext2D,\r\n    onUpdate: (newState: GameState) => void\r\n  ) => {\r\n    // render loop control\r\n    requestAnimationFrame(() => animate(canvas, ctx, onUpdate));\r\n    const now = Date.now();\r\n    const elapsed = now - then;\r\n    if (elapsed > frameInterval) {\r\n      then = now - (elapsed % frameInterval);\r\n\r\n      // animation\r\n      ctx.fillStyle = \"black\";\r\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n      const {\r\n        playerPosition: { x: px, y: py },\r\n        trail,\r\n        applePosition: { x: ax, y: ay },\r\n        tailSize\r\n      } = mutableGameState;\r\n\r\n      const newPlayerPosition = {\r\n        x: px + velocity.x,\r\n        y: py + velocity.y\r\n      };\r\n\r\n      if (newPlayerPosition.x < 0) {\r\n        newPlayerPosition.x = CONSTANTS.gridSize - 1;\r\n      }\r\n      if (newPlayerPosition.x > CONSTANTS.gridSize - 1) {\r\n        newPlayerPosition.x = 0;\r\n      }\r\n      if (newPlayerPosition.y < 0) {\r\n        newPlayerPosition.y = CONSTANTS.gridSize - 1;\r\n      }\r\n      if (newPlayerPosition.y > CONSTANTS.gridSize - 1) {\r\n        newPlayerPosition.y = 0;\r\n      }\r\n\r\n      ctx.fillStyle = \"lime\";\r\n      let newTailSize = tailSize;\r\n      for (var i = 0; i < trail.length; i++) {\r\n        ctx.fillRect(\r\n          trail[i].x * CONSTANTS.gridSize,\r\n          trail[i].y * CONSTANTS.gridSize,\r\n          CONSTANTS.tileSize,\r\n          CONSTANTS.tileSize\r\n        );\r\n        if (\r\n          trail[i].x === newPlayerPosition.x &&\r\n          trail[i].y === newPlayerPosition.y\r\n        ) {\r\n          newTailSize = 5;\r\n          frameInterval = 1000 / START_FPS;\r\n        }\r\n      }\r\n\r\n      const isOnApple =\r\n        ax === newPlayerPosition.x && ay === newPlayerPosition.y;\r\n      if (isOnApple) {\r\n        // grow tail\r\n        newTailSize++;\r\n        // speed up\r\n        frameInterval *= difficulty;\r\n      }\r\n\r\n      const newGameState = {\r\n        playerPosition: newPlayerPosition,\r\n        trail:\r\n          JSON.stringify(trail[trail.length - 1]) !==\r\n          JSON.stringify(newPlayerPosition)\r\n            ? trail\r\n                .concat(newPlayerPosition)\r\n                .slice(-newTailSize)\r\n            : trail,\r\n        applePosition: isOnApple\r\n          ? {\r\n              x: Math.floor(Math.random() * CONSTANTS.gridSize),\r\n              y: Math.floor(Math.random() * CONSTANTS.gridSize)\r\n            }\r\n          : { x: ax, y: ay },\r\n        tailSize: newTailSize\r\n      };\r\n\r\n      ctx.fillStyle = \"red\";\r\n      ctx.fillRect(\r\n        ax * CONSTANTS.gridSize,\r\n        ay * CONSTANTS.gridSize,\r\n        CONSTANTS.tileSize,\r\n        CONSTANTS.tileSize\r\n      );\r\n\r\n      if (JSON.stringify(mutableGameState) !== JSON.stringify(newGameState)) {\r\n        mutableGameState = newGameState;\r\n        onUpdate(newGameState);\r\n      }\r\n    }\r\n  };\r\n  animate(canvas, ctx, onUpdate);\r\n  // return setVelocity method\r\n  return {\r\n    setVelocity\r\n  };\r\n};\r\n","import * as React from \"react\";\nimport {\n  CONSTANTS,\n  Velocity,\n  startGame,\n  DifficultyMultiplier\n} from \"./Game\";\n\nconst velocityByKeyCode: {[key: number]: Velocity} = {\n  37: { x: -1, y: 0 },\n  38: { x: 0, y: -1 },\n  39: { x: 1, y: 0 },\n  40: { x: 0, y: 1 },\n}\n\nconst handleKeyDown = (\n  setVelocity: (velocity: Velocity) => void,\n  { keyCode }: React.KeyboardEvent<HTMLDivElement>\n) => {\n  if (velocityByKeyCode[keyCode]) {\n    setVelocity(velocityByKeyCode[keyCode]);\n  }\n};\n\nexport default function Snake() {\n  const canvasRef = React.useRef<HTMLCanvasElement | null>(null);\n  // not really stateful but state is convenient to perform an update once we have this\n  const [setVelocity, setVelocitySetter] = React.useState<\n    ReturnType<typeof startGame>[\"setVelocity\"]\n  >(() => () => {});\n\n  React.useLayoutEffect(() => {\n    if (canvasRef.current) {\n      const { current: canvas } = canvasRef;\n      const ctx = canvasRef.current.getContext(\"2d\");\n      if (ctx) {\n        const game = startGame(DifficultyMultiplier.MEDIUM, 5, canvas, ctx);\n        setVelocitySetter(() => game.setVelocity);\n      }\n    }\n  }, []);\n\n  return (\n    <div\n      className=\"snake\"\n      onKeyDown={handleKeyDown.bind(null, setVelocity)}\n      tabIndex={1}\n    >\n      <canvas\n        ref={canvasRef}\n        width={CONSTANTS.gridSize * 20}\n        height={CONSTANTS.gridSize * 20}\n      />\n    </div>\n  );\n}\n","import * as React from \"react\";\nimport { render } from \"react-dom\";\n\nimport Snake from \"./game/Snake\";\n\nconst rootElement = document.getElementById(\"root\");\nrender(<Snake />, rootElement);\n"],"sourceRoot":""}